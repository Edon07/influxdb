// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: predicate.proto

package storage

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Predicate_Comparison int32

const (
	// ComparisonEqual denotes the equal comparison operator.
	ComparisonEqual Predicate_Comparison = 0
	// ComparisonNotEqual denotes the not equal comparison operator.
	ComparisonNotEqual Predicate_Comparison = 1
	// ComparisonStartsWith denotes the starts with string comparison operator.
	ComparisonStartsWith Predicate_Comparison = 2
	// ComparisonRegex denotes the regex string comparison operator.
	ComparisonRegex Predicate_Comparison = 3
	// ComparisonNotRegex denotes the negated regex string comparison operator.
	ComparisonNotRegex Predicate_Comparison = 4
)

var Predicate_Comparison_name = map[int32]string{
	0: "EQUAL",
	1: "NEQUAL",
	2: "STARTS_WITH",
	3: "REGEX",
	4: "NREGEX",
}
var Predicate_Comparison_value = map[string]int32{
	"EQUAL":       0,
	"NEQUAL":      1,
	"STARTS_WITH": 2,
	"REGEX":       3,
	"NREGEX":      4,
}

func (x Predicate_Comparison) String() string {
	return proto.EnumName(Predicate_Comparison_name, int32(x))
}
func (Predicate_Comparison) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorPredicate, []int{0, 0}
}

// Logical operators apply to boolean values and combine to produce a single boolean result.
type Predicate_Logical int32

const (
	LogicalAnd Predicate_Logical = 0
	LogicalOr  Predicate_Logical = 1
)

var Predicate_Logical_name = map[int32]string{
	0: "AND",
	1: "OR",
}
var Predicate_Logical_value = map[string]int32{
	"AND": 0,
	"OR":  1,
}

func (x Predicate_Logical) String() string {
	return proto.EnumName(Predicate_Logical_name, int32(x))
}
func (Predicate_Logical) EnumDescriptor() ([]byte, []int) { return fileDescriptorPredicate, []int{0, 1} }

type Predicate struct {
	Root *Predicate_Expression `protobuf:"bytes,1,opt,name=root" json:"root,omitempty"`
}

func (m *Predicate) Reset()                    { *m = Predicate{} }
func (m *Predicate) String() string            { return proto.CompactTextString(m) }
func (*Predicate) ProtoMessage()               {}
func (*Predicate) Descriptor() ([]byte, []int) { return fileDescriptorPredicate, []int{0} }

func (m *Predicate) GetRoot() *Predicate_Expression {
	if m != nil {
		return m.Root
	}
	return nil
}

type Predicate_Expression struct {
	// Types that are valid to be assigned to Value:
	//	*Predicate_Expression_BinaryExpression
	//	*Predicate_Expression_GroupExpression
	Value isPredicate_Expression_Value `protobuf_oneof:"value"`
}

func (m *Predicate_Expression) Reset()                    { *m = Predicate_Expression{} }
func (m *Predicate_Expression) String() string            { return proto.CompactTextString(m) }
func (*Predicate_Expression) ProtoMessage()               {}
func (*Predicate_Expression) Descriptor() ([]byte, []int) { return fileDescriptorPredicate, []int{0, 0} }

type isPredicate_Expression_Value interface {
	isPredicate_Expression_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Predicate_Expression_BinaryExpression struct {
	BinaryExpression *Predicate_BooleanExpression `protobuf:"bytes,1,opt,name=binary_expression,json=binaryExpression,oneof"`
}
type Predicate_Expression_GroupExpression struct {
	GroupExpression *Predicate_GroupExpression `protobuf:"bytes,2,opt,name=group_expression,json=groupExpression,oneof"`
}

func (*Predicate_Expression_BinaryExpression) isPredicate_Expression_Value() {}
func (*Predicate_Expression_GroupExpression) isPredicate_Expression_Value()  {}

func (m *Predicate_Expression) GetValue() isPredicate_Expression_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Predicate_Expression) GetBinaryExpression() *Predicate_BooleanExpression {
	if x, ok := m.GetValue().(*Predicate_Expression_BinaryExpression); ok {
		return x.BinaryExpression
	}
	return nil
}

func (m *Predicate_Expression) GetGroupExpression() *Predicate_GroupExpression {
	if x, ok := m.GetValue().(*Predicate_Expression_GroupExpression); ok {
		return x.GroupExpression
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Predicate_Expression) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Predicate_Expression_OneofMarshaler, _Predicate_Expression_OneofUnmarshaler, _Predicate_Expression_OneofSizer, []interface{}{
		(*Predicate_Expression_BinaryExpression)(nil),
		(*Predicate_Expression_GroupExpression)(nil),
	}
}

func _Predicate_Expression_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Predicate_Expression)
	// value
	switch x := m.Value.(type) {
	case *Predicate_Expression_BinaryExpression:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BinaryExpression); err != nil {
			return err
		}
	case *Predicate_Expression_GroupExpression:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GroupExpression); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Predicate_Expression.Value has unexpected type %T", x)
	}
	return nil
}

func _Predicate_Expression_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Predicate_Expression)
	switch tag {
	case 1: // value.binary_expression
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Predicate_BooleanExpression)
		err := b.DecodeMessage(msg)
		m.Value = &Predicate_Expression_BinaryExpression{msg}
		return true, err
	case 2: // value.group_expression
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Predicate_GroupExpression)
		err := b.DecodeMessage(msg)
		m.Value = &Predicate_Expression_GroupExpression{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Predicate_Expression_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Predicate_Expression)
	// value
	switch x := m.Value.(type) {
	case *Predicate_Expression_BinaryExpression:
		s := proto.Size(x.BinaryExpression)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Predicate_Expression_GroupExpression:
		s := proto.Size(x.GroupExpression)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GroupExpression combines a group of expressions using either a logical AND or OR operator
type Predicate_GroupExpression struct {
	Op          Predicate_Logical       `protobuf:"varint,1,opt,name=op,proto3,enum=storage.Predicate_Logical" json:"op,omitempty"`
	Expressions []*Predicate_Expression `protobuf:"bytes,2,rep,name=expressions" json:"expressions,omitempty"`
}

func (m *Predicate_GroupExpression) Reset()         { *m = Predicate_GroupExpression{} }
func (m *Predicate_GroupExpression) String() string { return proto.CompactTextString(m) }
func (*Predicate_GroupExpression) ProtoMessage()    {}
func (*Predicate_GroupExpression) Descriptor() ([]byte, []int) {
	return fileDescriptorPredicate, []int{0, 1}
}

func (m *Predicate_GroupExpression) GetOp() Predicate_Logical {
	if m != nil {
		return m.Op
	}
	return LogicalAnd
}

func (m *Predicate_GroupExpression) GetExpressions() []*Predicate_Expression {
	if m != nil {
		return m.Expressions
	}
	return nil
}

// BooleanExpressions compares two operands and yieds a boolean result
type Predicate_BooleanExpression struct {
	LHS *Predicate_LiteralExpression `protobuf:"bytes,1,opt,name=lhs" json:"lhs,omitempty"`
	Op  Predicate_Comparison         `protobuf:"varint,2,opt,name=op,proto3,enum=storage.Predicate_Comparison" json:"op,omitempty"`
	RHS *Predicate_LiteralExpression `protobuf:"bytes,3,opt,name=rhs" json:"rhs,omitempty"`
}

func (m *Predicate_BooleanExpression) Reset()         { *m = Predicate_BooleanExpression{} }
func (m *Predicate_BooleanExpression) String() string { return proto.CompactTextString(m) }
func (*Predicate_BooleanExpression) ProtoMessage()    {}
func (*Predicate_BooleanExpression) Descriptor() ([]byte, []int) {
	return fileDescriptorPredicate, []int{0, 2}
}

func (m *Predicate_BooleanExpression) GetLHS() *Predicate_LiteralExpression {
	if m != nil {
		return m.LHS
	}
	return nil
}

func (m *Predicate_BooleanExpression) GetOp() Predicate_Comparison {
	if m != nil {
		return m.Op
	}
	return ComparisonEqual
}

func (m *Predicate_BooleanExpression) GetRHS() *Predicate_LiteralExpression {
	if m != nil {
		return m.RHS
	}
	return nil
}

// ValueExpression represents a tag or literal value
type Predicate_ValueExpression struct {
	// Types that are valid to be assigned to Value:
	//	*Predicate_ValueExpression_Ref
	//	*Predicate_ValueExpression_Literal
	Value isPredicate_ValueExpression_Value `protobuf_oneof:"value"`
}

func (m *Predicate_ValueExpression) Reset()         { *m = Predicate_ValueExpression{} }
func (m *Predicate_ValueExpression) String() string { return proto.CompactTextString(m) }
func (*Predicate_ValueExpression) ProtoMessage()    {}
func (*Predicate_ValueExpression) Descriptor() ([]byte, []int) {
	return fileDescriptorPredicate, []int{0, 3}
}

type isPredicate_ValueExpression_Value interface {
	isPredicate_ValueExpression_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Predicate_ValueExpression_Ref struct {
	Ref *Predicate_RefExpression `protobuf:"bytes,1,opt,name=ref,oneof"`
}
type Predicate_ValueExpression_Literal struct {
	Literal *Predicate_LiteralExpression `protobuf:"bytes,2,opt,name=literal,oneof"`
}

func (*Predicate_ValueExpression_Ref) isPredicate_ValueExpression_Value()     {}
func (*Predicate_ValueExpression_Literal) isPredicate_ValueExpression_Value() {}

func (m *Predicate_ValueExpression) GetValue() isPredicate_ValueExpression_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Predicate_ValueExpression) GetRef() *Predicate_RefExpression {
	if x, ok := m.GetValue().(*Predicate_ValueExpression_Ref); ok {
		return x.Ref
	}
	return nil
}

func (m *Predicate_ValueExpression) GetLiteral() *Predicate_LiteralExpression {
	if x, ok := m.GetValue().(*Predicate_ValueExpression_Literal); ok {
		return x.Literal
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Predicate_ValueExpression) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Predicate_ValueExpression_OneofMarshaler, _Predicate_ValueExpression_OneofUnmarshaler, _Predicate_ValueExpression_OneofSizer, []interface{}{
		(*Predicate_ValueExpression_Ref)(nil),
		(*Predicate_ValueExpression_Literal)(nil),
	}
}

func _Predicate_ValueExpression_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Predicate_ValueExpression)
	// value
	switch x := m.Value.(type) {
	case *Predicate_ValueExpression_Ref:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ref); err != nil {
			return err
		}
	case *Predicate_ValueExpression_Literal:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Literal); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Predicate_ValueExpression.Value has unexpected type %T", x)
	}
	return nil
}

func _Predicate_ValueExpression_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Predicate_ValueExpression)
	switch tag {
	case 1: // value.ref
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Predicate_RefExpression)
		err := b.DecodeMessage(msg)
		m.Value = &Predicate_ValueExpression_Ref{msg}
		return true, err
	case 2: // value.literal
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Predicate_LiteralExpression)
		err := b.DecodeMessage(msg)
		m.Value = &Predicate_ValueExpression_Literal{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Predicate_ValueExpression_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Predicate_ValueExpression)
	// value
	switch x := m.Value.(type) {
	case *Predicate_ValueExpression_Ref:
		s := proto.Size(x.Ref)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Predicate_ValueExpression_Literal:
		s := proto.Size(x.Literal)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RefExpression represents a tag reference
type Predicate_RefExpression struct {
	Ref string `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
}

func (m *Predicate_RefExpression) Reset()         { *m = Predicate_RefExpression{} }
func (m *Predicate_RefExpression) String() string { return proto.CompactTextString(m) }
func (*Predicate_RefExpression) ProtoMessage()    {}
func (*Predicate_RefExpression) Descriptor() ([]byte, []int) {
	return fileDescriptorPredicate, []int{0, 4}
}

func (m *Predicate_RefExpression) GetRef() string {
	if m != nil {
		return m.Ref
	}
	return ""
}

// LiteralExpression represents a typed literal value
type Predicate_LiteralExpression struct {
	// Types that are valid to be assigned to Value:
	//	*Predicate_LiteralExpression_StringValue
	//	*Predicate_LiteralExpression_BooleanValue
	//	*Predicate_LiteralExpression_IntegerValue
	//	*Predicate_LiteralExpression_UnsignedValue
	//	*Predicate_LiteralExpression_FloatValue
	Value isPredicate_LiteralExpression_Value `protobuf_oneof:"value"`
}

func (m *Predicate_LiteralExpression) Reset()         { *m = Predicate_LiteralExpression{} }
func (m *Predicate_LiteralExpression) String() string { return proto.CompactTextString(m) }
func (*Predicate_LiteralExpression) ProtoMessage()    {}
func (*Predicate_LiteralExpression) Descriptor() ([]byte, []int) {
	return fileDescriptorPredicate, []int{0, 5}
}

type isPredicate_LiteralExpression_Value interface {
	isPredicate_LiteralExpression_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Predicate_LiteralExpression_StringValue struct {
	StringValue string `protobuf:"bytes,1,opt,name=string_value,json=stringValue,proto3,oneof"`
}
type Predicate_LiteralExpression_BooleanValue struct {
	BooleanValue bool `protobuf:"varint,2,opt,name=bool_value,json=boolValue,proto3,oneof"`
}
type Predicate_LiteralExpression_IntegerValue struct {
	IntegerValue int64 `protobuf:"varint,3,opt,name=int_value,json=intValue,proto3,oneof"`
}
type Predicate_LiteralExpression_UnsignedValue struct {
	UnsignedValue uint64 `protobuf:"varint,4,opt,name=uint_value,json=uintValue,proto3,oneof"`
}
type Predicate_LiteralExpression_FloatValue struct {
	FloatValue float32 `protobuf:"fixed32,5,opt,name=float_value,json=floatValue,proto3,oneof"`
}

func (*Predicate_LiteralExpression_StringValue) isPredicate_LiteralExpression_Value()   {}
func (*Predicate_LiteralExpression_BooleanValue) isPredicate_LiteralExpression_Value()  {}
func (*Predicate_LiteralExpression_IntegerValue) isPredicate_LiteralExpression_Value()  {}
func (*Predicate_LiteralExpression_UnsignedValue) isPredicate_LiteralExpression_Value() {}
func (*Predicate_LiteralExpression_FloatValue) isPredicate_LiteralExpression_Value()    {}

func (m *Predicate_LiteralExpression) GetValue() isPredicate_LiteralExpression_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Predicate_LiteralExpression) GetStringValue() string {
	if x, ok := m.GetValue().(*Predicate_LiteralExpression_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *Predicate_LiteralExpression) GetBooleanValue() bool {
	if x, ok := m.GetValue().(*Predicate_LiteralExpression_BooleanValue); ok {
		return x.BooleanValue
	}
	return false
}

func (m *Predicate_LiteralExpression) GetIntegerValue() int64 {
	if x, ok := m.GetValue().(*Predicate_LiteralExpression_IntegerValue); ok {
		return x.IntegerValue
	}
	return 0
}

func (m *Predicate_LiteralExpression) GetUnsignedValue() uint64 {
	if x, ok := m.GetValue().(*Predicate_LiteralExpression_UnsignedValue); ok {
		return x.UnsignedValue
	}
	return 0
}

func (m *Predicate_LiteralExpression) GetFloatValue() float32 {
	if x, ok := m.GetValue().(*Predicate_LiteralExpression_FloatValue); ok {
		return x.FloatValue
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Predicate_LiteralExpression) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Predicate_LiteralExpression_OneofMarshaler, _Predicate_LiteralExpression_OneofUnmarshaler, _Predicate_LiteralExpression_OneofSizer, []interface{}{
		(*Predicate_LiteralExpression_StringValue)(nil),
		(*Predicate_LiteralExpression_BooleanValue)(nil),
		(*Predicate_LiteralExpression_IntegerValue)(nil),
		(*Predicate_LiteralExpression_UnsignedValue)(nil),
		(*Predicate_LiteralExpression_FloatValue)(nil),
	}
}

func _Predicate_LiteralExpression_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Predicate_LiteralExpression)
	// value
	switch x := m.Value.(type) {
	case *Predicate_LiteralExpression_StringValue:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.StringValue)
	case *Predicate_LiteralExpression_BooleanValue:
		t := uint64(0)
		if x.BooleanValue {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *Predicate_LiteralExpression_IntegerValue:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.IntegerValue))
	case *Predicate_LiteralExpression_UnsignedValue:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.UnsignedValue))
	case *Predicate_LiteralExpression_FloatValue:
		_ = b.EncodeVarint(5<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.FloatValue)))
	case nil:
	default:
		return fmt.Errorf("Predicate_LiteralExpression.Value has unexpected type %T", x)
	}
	return nil
}

func _Predicate_LiteralExpression_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Predicate_LiteralExpression)
	switch tag {
	case 1: // value.string_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Predicate_LiteralExpression_StringValue{x}
		return true, err
	case 2: // value.bool_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Predicate_LiteralExpression_BooleanValue{x != 0}
		return true, err
	case 3: // value.int_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Predicate_LiteralExpression_IntegerValue{int64(x)}
		return true, err
	case 4: // value.uint_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Predicate_LiteralExpression_UnsignedValue{x}
		return true, err
	case 5: // value.float_value
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Value = &Predicate_LiteralExpression_FloatValue{math.Float32frombits(uint32(x))}
		return true, err
	default:
		return false, nil
	}
}

func _Predicate_LiteralExpression_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Predicate_LiteralExpression)
	// value
	switch x := m.Value.(type) {
	case *Predicate_LiteralExpression_StringValue:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.StringValue)))
		n += len(x.StringValue)
	case *Predicate_LiteralExpression_BooleanValue:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case *Predicate_LiteralExpression_IntegerValue:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IntegerValue))
	case *Predicate_LiteralExpression_UnsignedValue:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.UnsignedValue))
	case *Predicate_LiteralExpression_FloatValue:
		n += proto.SizeVarint(5<<3 | proto.WireFixed32)
		n += 4
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Predicate)(nil), "storage.Predicate")
	proto.RegisterType((*Predicate_Expression)(nil), "storage.Predicate.Expression")
	proto.RegisterType((*Predicate_GroupExpression)(nil), "storage.Predicate.GroupExpression")
	proto.RegisterType((*Predicate_BooleanExpression)(nil), "storage.Predicate.BooleanExpression")
	proto.RegisterType((*Predicate_ValueExpression)(nil), "storage.Predicate.ValueExpression")
	proto.RegisterType((*Predicate_RefExpression)(nil), "storage.Predicate.RefExpression")
	proto.RegisterType((*Predicate_LiteralExpression)(nil), "storage.Predicate.LiteralExpression")
	proto.RegisterEnum("storage.Predicate_Comparison", Predicate_Comparison_name, Predicate_Comparison_value)
	proto.RegisterEnum("storage.Predicate_Logical", Predicate_Logical_name, Predicate_Logical_value)
}
func (m *Predicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Predicate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Root != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredicate(dAtA, i, uint64(m.Root.Size()))
		n1, err := m.Root.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Predicate_Expression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Predicate_Expression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn2, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *Predicate_Expression_BinaryExpression) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BinaryExpression != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredicate(dAtA, i, uint64(m.BinaryExpression.Size()))
		n3, err := m.BinaryExpression.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Predicate_Expression_GroupExpression) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GroupExpression != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredicate(dAtA, i, uint64(m.GroupExpression.Size()))
		n4, err := m.GroupExpression.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Predicate_GroupExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Predicate_GroupExpression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPredicate(dAtA, i, uint64(m.Op))
	}
	if len(m.Expressions) > 0 {
		for _, msg := range m.Expressions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPredicate(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Predicate_BooleanExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Predicate_BooleanExpression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LHS != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredicate(dAtA, i, uint64(m.LHS.Size()))
		n5, err := m.LHS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPredicate(dAtA, i, uint64(m.Op))
	}
	if m.RHS != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPredicate(dAtA, i, uint64(m.RHS.Size()))
		n6, err := m.RHS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *Predicate_ValueExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Predicate_ValueExpression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn7, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	return i, nil
}

func (m *Predicate_ValueExpression_Ref) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ref != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredicate(dAtA, i, uint64(m.Ref.Size()))
		n8, err := m.Ref.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Predicate_ValueExpression_Literal) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Literal != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPredicate(dAtA, i, uint64(m.Literal.Size()))
		n9, err := m.Literal.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Predicate_RefExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Predicate_RefExpression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPredicate(dAtA, i, uint64(len(m.Ref)))
		i += copy(dAtA[i:], m.Ref)
	}
	return i, nil
}

func (m *Predicate_LiteralExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Predicate_LiteralExpression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn10, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	return i, nil
}

func (m *Predicate_LiteralExpression_StringValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintPredicate(dAtA, i, uint64(len(m.StringValue)))
	i += copy(dAtA[i:], m.StringValue)
	return i, nil
}
func (m *Predicate_LiteralExpression_BooleanValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.BooleanValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Predicate_LiteralExpression_IntegerValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintPredicate(dAtA, i, uint64(m.IntegerValue))
	return i, nil
}
func (m *Predicate_LiteralExpression_UnsignedValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintPredicate(dAtA, i, uint64(m.UnsignedValue))
	return i, nil
}
func (m *Predicate_LiteralExpression_FloatValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x2d
	i++
	i = encodeFixed32Predicate(dAtA, i, uint32(math.Float32bits(float32(m.FloatValue))))
	return i, nil
}
func encodeFixed64Predicate(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Predicate(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintPredicate(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Predicate) Size() (n int) {
	var l int
	_ = l
	if m.Root != nil {
		l = m.Root.Size()
		n += 1 + l + sovPredicate(uint64(l))
	}
	return n
}

func (m *Predicate_Expression) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Predicate_Expression_BinaryExpression) Size() (n int) {
	var l int
	_ = l
	if m.BinaryExpression != nil {
		l = m.BinaryExpression.Size()
		n += 1 + l + sovPredicate(uint64(l))
	}
	return n
}
func (m *Predicate_Expression_GroupExpression) Size() (n int) {
	var l int
	_ = l
	if m.GroupExpression != nil {
		l = m.GroupExpression.Size()
		n += 1 + l + sovPredicate(uint64(l))
	}
	return n
}
func (m *Predicate_GroupExpression) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovPredicate(uint64(m.Op))
	}
	if len(m.Expressions) > 0 {
		for _, e := range m.Expressions {
			l = e.Size()
			n += 1 + l + sovPredicate(uint64(l))
		}
	}
	return n
}

func (m *Predicate_BooleanExpression) Size() (n int) {
	var l int
	_ = l
	if m.LHS != nil {
		l = m.LHS.Size()
		n += 1 + l + sovPredicate(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovPredicate(uint64(m.Op))
	}
	if m.RHS != nil {
		l = m.RHS.Size()
		n += 1 + l + sovPredicate(uint64(l))
	}
	return n
}

func (m *Predicate_ValueExpression) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Predicate_ValueExpression_Ref) Size() (n int) {
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.Size()
		n += 1 + l + sovPredicate(uint64(l))
	}
	return n
}
func (m *Predicate_ValueExpression_Literal) Size() (n int) {
	var l int
	_ = l
	if m.Literal != nil {
		l = m.Literal.Size()
		n += 1 + l + sovPredicate(uint64(l))
	}
	return n
}
func (m *Predicate_RefExpression) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ref)
	if l > 0 {
		n += 1 + l + sovPredicate(uint64(l))
	}
	return n
}

func (m *Predicate_LiteralExpression) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Predicate_LiteralExpression_StringValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.StringValue)
	n += 1 + l + sovPredicate(uint64(l))
	return n
}
func (m *Predicate_LiteralExpression_BooleanValue) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *Predicate_LiteralExpression_IntegerValue) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPredicate(uint64(m.IntegerValue))
	return n
}
func (m *Predicate_LiteralExpression_UnsignedValue) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPredicate(uint64(m.UnsignedValue))
	return n
}
func (m *Predicate_LiteralExpression_FloatValue) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}

func sovPredicate(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPredicate(x uint64) (n int) {
	return sovPredicate(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Predicate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredicate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Predicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Predicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredicate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Root == nil {
				m.Root = &Predicate_Expression{}
			}
			if err := m.Root.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredicate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredicate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Predicate_Expression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredicate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredicate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Predicate_BooleanExpression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Predicate_Expression_BinaryExpression{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredicate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Predicate_GroupExpression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Predicate_Expression_GroupExpression{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredicate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredicate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Predicate_GroupExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredicate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (Predicate_Logical(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredicate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expressions = append(m.Expressions, &Predicate_Expression{})
			if err := m.Expressions[len(m.Expressions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredicate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredicate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Predicate_BooleanExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredicate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BooleanExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BooleanExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LHS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredicate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LHS == nil {
				m.LHS = &Predicate_LiteralExpression{}
			}
			if err := m.LHS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (Predicate_Comparison(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RHS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredicate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RHS == nil {
				m.RHS = &Predicate_LiteralExpression{}
			}
			if err := m.RHS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredicate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredicate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Predicate_ValueExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredicate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredicate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Predicate_RefExpression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Predicate_ValueExpression_Ref{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Literal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredicate
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Predicate_LiteralExpression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Predicate_ValueExpression_Literal{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredicate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredicate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Predicate_RefExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredicate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredicate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredicate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredicate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Predicate_LiteralExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredicate
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiteralExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiteralExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredicate
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Predicate_LiteralExpression_StringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BooleanValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Predicate_LiteralExpression_BooleanValue{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntegerValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Predicate_LiteralExpression_IntegerValue{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsignedValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Predicate_LiteralExpression_UnsignedValue{v}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Value = &Predicate_LiteralExpression_FloatValue{float32(math.Float32frombits(v))}
		default:
			iNdEx = preIndex
			skippy, err := skipPredicate(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPredicate
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPredicate(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPredicate
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPredicate
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPredicate
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPredicate
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPredicate(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPredicate = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPredicate   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("predicate.proto", fileDescriptorPredicate) }

var fileDescriptorPredicate = []byte{
	// 698 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcb, 0x6e, 0xd3, 0x4a,
	0x18, 0xf6, 0x25, 0x6d, 0x9a, 0x3f, 0x6d, 0xe3, 0x4c, 0x7b, 0xce, 0x89, 0x2c, 0x9d, 0xc4, 0x44,
	0x2c, 0x0a, 0x52, 0x53, 0xb5, 0x74, 0x5f, 0x62, 0x08, 0x4d, 0xa5, 0xa8, 0x05, 0xa7, 0xa5, 0xec,
	0x2a, 0xa7, 0x99, 0x38, 0x96, 0x5c, 0x8f, 0x19, 0x8f, 0x51, 0xd9, 0xb0, 0x46, 0x59, 0x21, 0xf6,
	0x59, 0xf1, 0x2a, 0x20, 0xb1, 0x83, 0x27, 0xb0, 0x90, 0x91, 0x78, 0x0e, 0xe4, 0xb1, 0x13, 0xa7,
	0x69, 0xc4, 0x65, 0x97, 0xf9, 0xe6, 0xbb, 0xfc, 0xdf, 0x3f, 0x49, 0xa0, 0xe4, 0x51, 0xdc, 0xb7,
	0x2f, 0x4d, 0x86, 0x1b, 0x1e, 0x25, 0x8c, 0xa0, 0xbc, 0xcf, 0x08, 0x35, 0x2d, 0xac, 0x6e, 0x5b,
	0x36, 0x1b, 0x06, 0xbd, 0xc6, 0x25, 0xb9, 0xda, 0xb1, 0x88, 0x45, 0x76, 0xf8, 0x7d, 0x2f, 0x18,
	0xf0, 0x13, 0x3f, 0xf0, 0x4f, 0x89, 0xae, 0xfe, 0x05, 0xa0, 0xf0, 0x74, 0xe2, 0x85, 0x76, 0x21,
	0x47, 0x09, 0x61, 0x15, 0x51, 0x13, 0xb7, 0x8a, 0x7b, 0xff, 0x37, 0x52, 0xd3, 0xc6, 0x94, 0xd1,
	0x68, 0x5d, 0x7b, 0x14, 0xfb, 0xbe, 0x4d, 0x5c, 0x83, 0x53, 0xd5, 0x1f, 0x22, 0x40, 0x06, 0x22,
	0x1b, 0xca, 0x3d, 0xdb, 0x35, 0xe9, 0xeb, 0x0b, 0x3c, 0x05, 0x53, 0xbb, 0xbb, 0x0b, 0xec, 0x74,
	0x42, 0x1c, 0x6c, 0xba, 0x99, 0x81, 0xbe, 0x19, 0x85, 0x35, 0x45, 0xe7, 0x16, 0x19, 0xda, 0x16,
	0x0c, 0xa5, 0x37, 0x87, 0xa1, 0x3e, 0x28, 0x16, 0x25, 0x81, 0x37, 0x9b, 0x24, 0xf1, 0xa4, 0xfa,
	0x82, 0xa4, 0xc3, 0x98, 0x3a, 0x93, 0xb3, 0x11, 0x85, 0xb5, 0xd2, 0x1c, 0xd8, 0x16, 0x8c, 0x92,
	0x35, 0xc7, 0xcb, 0xc3, 0xd2, 0x2b, 0xd3, 0x09, 0xb0, 0xfa, 0x06, 0xe6, 0xe9, 0xe8, 0x3e, 0x48,
	0xc4, 0xe3, 0xed, 0xd6, 0xf7, 0xd4, 0x05, 0x99, 0x1d, 0x62, 0xd9, 0x97, 0xa6, 0x63, 0x48, 0xc4,
	0x43, 0x07, 0x50, 0xcc, 0xe6, 0xf4, 0x2b, 0x92, 0x26, 0xff, 0x7e, 0xc3, 0xb3, 0x0a, 0xf5, 0xa3,
	0x08, 0xe5, 0x5b, 0xeb, 0x42, 0x07, 0x20, 0x3b, 0x43, 0xff, 0x17, 0x1b, 0xee, 0xd8, 0x0c, 0x53,
	0xd3, 0x99, 0x6d, 0x14, 0x85, 0x35, 0xb9, 0xd3, 0xee, 0x1a, 0xb1, 0x12, 0x6d, 0xf3, 0x0e, 0x12,
	0xef, 0xb0, 0x68, 0x9c, 0x47, 0xe4, 0xca, 0x33, 0xa9, 0xed, 0x13, 0x37, 0xad, 0x21, 0xd3, 0xa1,
	0x5f, 0x91, 0xff, 0x36, 0xcf, 0x88, 0xf3, 0xe8, 0xd0, 0x57, 0xdf, 0x8b, 0x50, 0x7a, 0x1e, 0x2f,
	0x74, 0xa6, 0xc4, 0x3e, 0xc8, 0x14, 0x0f, 0xd2, 0x12, 0xda, 0x02, 0x53, 0x03, 0x0f, 0x6e, 0xbc,
	0x52, 0x4c, 0x47, 0x0f, 0x21, 0xef, 0x24, 0x61, 0xe9, 0xb3, 0xff, 0xd1, 0x38, 0x6d, 0xc1, 0x98,
	0xc8, 0xb2, 0xb7, 0xbd, 0x03, 0x6b, 0x37, 0x22, 0x90, 0x92, 0x4d, 0x54, 0xe0, 0x69, 0xea, 0x58,
	0x82, 0xf2, 0x2d, 0x33, 0xb4, 0x0f, 0xab, 0x3e, 0xa3, 0xb6, 0x6b, 0x5d, 0x70, 0xa3, 0x44, 0xa0,
	0x97, 0xa2, 0xb0, 0x56, 0xec, 0x72, 0x9c, 0x57, 0x6d, 0x0b, 0x46, 0xd1, 0xcf, 0x8e, 0x68, 0x17,
	0xa0, 0x47, 0x88, 0x93, 0x6a, 0xe2, 0xe1, 0x57, 0x74, 0x25, 0x0a, 0x6b, 0xab, 0xe9, 0xfb, 0x4e,
	0x44, 0x85, 0x98, 0x95, 0x48, 0x76, 0xa0, 0x60, 0xbb, 0x2c, 0x55, 0xc4, 0xdb, 0x97, 0x13, 0xc5,
	0x91, 0xcb, 0xb0, 0x85, 0xe9, 0x44, 0xb1, 0x62, 0xbb, 0x2c, 0x11, 0xec, 0x01, 0x04, 0x99, 0x22,
	0xa7, 0x89, 0x5b, 0x39, 0xbd, 0x1c, 0x85, 0xb5, 0xb5, 0x33, 0xd7, 0xb7, 0x2d, 0x17, 0xf7, 0xa7,
	0x21, 0xc1, 0x54, 0xb3, 0x0b, 0xc5, 0x81, 0x43, 0xcc, 0x89, 0x68, 0x49, 0x13, 0xb7, 0x24, 0x7d,
	0x3d, 0x0a, 0x6b, 0xf0, 0x24, 0x86, 0x27, 0x0a, 0x18, 0x4c, 0x4f, 0xd3, 0x15, 0xd6, 0x3f, 0x89,
	0x00, 0xd9, 0x77, 0x05, 0x55, 0x61, 0xa9, 0xf5, 0xec, 0xac, 0xd9, 0x51, 0x04, 0x75, 0x63, 0x34,
	0xd6, 0x4a, 0xd9, 0x55, 0xeb, 0x65, 0x60, 0x3a, 0xa8, 0x0e, 0xcb, 0xc7, 0x09, 0x41, 0x54, 0xff,
	0x1d, 0x8d, 0x35, 0x94, 0x11, 0x8e, 0x09, 0x4b, 0x38, 0xf7, 0xa0, 0xd8, 0x3d, 0x6d, 0x1a, 0xa7,
	0xdd, 0x8b, 0xf3, 0xa3, 0xd3, 0xb6, 0x22, 0xa9, 0x95, 0xd1, 0x58, 0xdb, 0xcc, 0x88, 0x5d, 0x66,
	0x52, 0xe6, 0x9f, 0xdb, 0x6c, 0x18, 0xc7, 0x19, 0xad, 0xc3, 0xd6, 0x0b, 0x45, 0x9e, 0x8f, 0x33,
	0xb0, 0x85, 0xaf, 0x79, 0x5c, 0x42, 0xc8, 0x2d, 0x88, 0xe3, 0x1c, 0x35, 0xf7, 0xf6, 0x43, 0x55,
	0xa8, 0x1f, 0x40, 0x3e, 0xfd, 0xd9, 0xa2, 0xff, 0x40, 0x6e, 0x1e, 0x3f, 0x56, 0x04, 0x75, 0x7d,
	0x34, 0xd6, 0x20, 0x45, 0x9b, 0x6e, 0x1f, 0xfd, 0x03, 0xd2, 0x89, 0xa1, 0x88, 0xea, 0xda, 0x68,
	0xac, 0x15, 0x52, 0xfc, 0x84, 0x26, 0x06, 0xba, 0xf2, 0x39, 0xaa, 0x8a, 0x5f, 0xa3, 0xaa, 0xf8,
	0x2d, 0xaa, 0x8a, 0xef, 0xbe, 0x57, 0x85, 0xde, 0x32, 0xff, 0xab, 0x7d, 0xf0, 0x33, 0x00, 0x00,
	0xff, 0xff, 0xc3, 0x01, 0x5e, 0xe1, 0xb5, 0x05, 0x00, 0x00,
}
